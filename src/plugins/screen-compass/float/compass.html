<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>屏幕罗盘</title>
    <link rel="stylesheet" href="../../../renderer/remixicon-local.css" />
    <style>
      html, body { height: 100%; overflow: hidden; }
      body { margin: 0; background: transparent; display:flex; align-items:center; justify-content:center; overflow: hidden; }
      .root { width: 100%; height: 100%; position: relative; display:flex; align-items:center; justify-content:center; overflow: hidden; }
      .center-btn { width: 50px; height: 50px; border-radius: 50%; display:flex; align-items:center; justify-content:center; background: rgba(20,28,40,0.62); border: 1px solid rgba(255,255,255,0.30); cursor: pointer; position: relative; z-index: 3; touch-action: none; }
      .center-btn i { font-size: 22px; color: #ffffff; }
      .center-btn:active { transform: scale(0.96); }
      .ring { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; pointer-events:none; z-index: 2; }
      .item { width: 44px; height: 58px; border-radius: 12px; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:4px; background: rgba(20,28,40,0.52); border: 1px solid rgba(255,255,255,0.28); pointer-events:auto; cursor:pointer; transition: opacity .2s ease, transform .2s ease; }
      .item i { font-size:22px; color:#e6f0ff; }
      .item .label { font-size:11px; line-height:12px; color:#e6f0ff; opacity:0.88; max-width:64px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
      .item:hover { transform: scale(1.06); }
      .hidden { opacity:0; transform: scale(0.6); pointer-events:none; }
      .sectors { position:absolute; inset:0; pointer-events:none; z-index: 1; }
      .wedge { transition: opacity .2s ease; }
      .circle-bg { position:absolute; inset:0; border-radius:50%; background: rgba(20,28,40,0.28); border: 1px solid rgba(255,255,255,0.18); pointer-events: auto; z-index: 0; }
      .sector .circle-bg { opacity: 1; }
      .classic .circle-bg { opacity: 0; }
      .classic .item { background: transparent; border: none; height: 58px; width: 56px; }
      .classic .item .dot { width: 52px; height: 52px; border-radius: 50%; display:flex; flex-direction:column; align-items:center; justify-content:center; gap:3px; background: rgba(20,28,40,0.62); border: 1px solid rgba(255,255,255,0.30); }
      .classic .item i { color:#ffffff; font-size: 19px; }
      .classic .item .label { font-size: 11px; line-height: 12px; max-width: 48px; margin: 0; text-align: center; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      .sector .item { background: transparent; border: none; }
    
    </style>
  </head>
  <body>
    <div class="root" id="root">
      <div class="circle-bg" id="circleBg"></div>
      <div class="sectors" id="sectors"></div>
      <div class="ring" id="ring"></div>
      <div class="center-btn" id="center"><i class="ri-compass-3-line"></i></div>
      
    </div>
    <script>
      const center = document.getElementById('center');
      const ring = document.getElementById('ring');
      
      let expanded = false;
      let items = [];
      const scope = 'screen-compass';
      let theme = 'classic';
      let activeIndex = -1;
      let toggleLock = false;
      let sizeCollapsed = 60;
      let sizeExpanded = 240;
      let centerSize = 50;
      let centerIcon = 'ri-compass-3-line';

      async function ensureDefaults() {
        const defaults = {
          buttons: [
            { id: 'rollcall', label: '随机点名', icon: 'ri-shuffle-line', actionType: 'plugin', actionPayload: { pluginId: 'rollcall.random', fn: 'openRollcallTemplate', args: [] } }
          ]
        };
        try { await window.compassAPI.configEnsureDefaults(scope, defaults); } catch {}
        try { await window.compassAPI.configEnsureDefaults(scope, { sizeCollapsed: 60, sizeExpanded: 240, centerSize: 50, centerIcon: 'ri-compass-3-line' }); } catch {}
      }

      async function loadItems() {
        try {
          const raw = await window.compassAPI.configGet(scope, 'buttons');
          const list = (raw && raw.result) ? raw.result : raw;
          items = Array.isArray(list) ? list : [];
        } catch { items = []; }
        try { const t = await window.compassAPI.configGet(scope, 'theme'); const v = (t && t.result) ? t.result : t; theme = (v === 'sector') ? 'sector' : 'classic'; } catch { theme = 'classic'; }
        try { const v = await window.compassAPI.configGet(scope, 'sizeCollapsed'); sizeCollapsed = Number((v && v.result) ? v.result : v) || 60; } catch { sizeCollapsed = 60; }
        try { const v = await window.compassAPI.configGet(scope, 'sizeExpanded'); sizeExpanded = Number((v && v.result) ? v.result : v) || 240; } catch { sizeExpanded = 240; }
        try { const v = await window.compassAPI.configGet(scope, 'centerSize'); centerSize = Number((v && v.result) ? v.result : v) || 50; } catch { centerSize = 50; }
        try { const v = await window.compassAPI.configGet(scope, 'centerIcon'); centerIcon = String((v && v.result) ? v.result : v || 'ri-compass-3-line'); } catch { centerIcon = 'ri-compass-3-line'; }
        try {
          centerSize = Math.max(32, Math.min(160, Number(centerSize || 50)));
          sizeCollapsed = Math.max(40, Math.min(240, Number(sizeCollapsed || (centerSize + 10))));
          centerSize = Math.max(32, Math.min(160, Number(sizeCollapsed - 10)));
          sizeCollapsed = Math.max(40, Math.min(240, Number(centerSize + 10)));
        } catch {}
      }

      function placeItems() {
        ring.innerHTML = '';
        const rootEl = document.getElementById('root');
        const sectors = document.getElementById('sectors'); sectors.innerHTML = '';
        const rootRect = (document.getElementById('root')?.getBoundingClientRect?.()) || { width: 0, height: 0 };
        const W = Math.max(200, Math.floor(rootRect.width || window.innerWidth || document.documentElement.clientWidth || 240));
        const H = Math.max(200, Math.floor(rootRect.height || window.innerHeight || document.documentElement.clientHeight || 240));
        if (W < 40 || H < 40) { try { setTimeout(placeItems, 50); } catch {} return; }
        const cx = Math.floor(W / 2), cy = Math.floor(H / 2);
        let R = Math.min(cx, cy) - 24; if (R < 22) R = 22;
        const N = items.length;
        try { if (theme === 'sector') { rootEl.classList.add('sector'); rootEl.classList.remove('classic'); } else { rootEl.classList.add('classic'); rootEl.classList.remove('sector'); } } catch {}
        if (theme === 'sector' && N > 0) {
          const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
          svg.setAttribute('width','100%');
          svg.setAttribute('height','100%');
          svg.setAttribute('viewBox',`0 0 ${W} ${H}`);
          const ro = Math.min(R + 14, Math.min(cx, cy) - 10);
          const centerR = 25;
          const ri = Math.max(centerR + 4, Math.round(R * 0.5));
          for (let i = 0; i < N; i++) {
            const a1 = (Math.PI * 2) * (i / N);
            const a2 = (Math.PI * 2) * ((i + 1) / N);
            const o1x = Math.round(cx + ro * Math.cos(a1));
            const o1y = Math.round(cy + ro * Math.sin(a1));
            const o2x = Math.round(cx + ro * Math.cos(a2));
            const o2y = Math.round(cy + ro * Math.sin(a2));
            const i2x = Math.round(cx + ri * Math.cos(a2));
            const i2y = Math.round(cy + ri * Math.sin(a2));
            const i1x = Math.round(cx + ri * Math.cos(a1));
            const i1y = Math.round(cy + ri * Math.sin(a1));
            const largeArc = ((a2 - a1) % (Math.PI*2)) > Math.PI ? 1 : 0;
            const path = document.createElementNS('http://www.w3.org/2000/svg','path');
            const d = `M ${o1x} ${o1y} A ${ro} ${ro} 0 ${largeArc} 1 ${o2x} ${o2y} L ${i2x} ${i2y} A ${ri} ${ri} 0 ${largeArc} 0 ${i1x} ${i1y} Z`;
            path.setAttribute('d', d);
            path.setAttribute('fill','rgba(64,128,255,0.18)');
            path.setAttribute('stroke','rgba(64,128,255,0.32)');
            path.setAttribute('stroke-width','1');
            path.style.opacity = (expanded && activeIndex === i) ? '1' : '0';
            path.setAttribute('class','wedge');
            path.dataset.index = String(i);
            path.addEventListener('mouseenter', () => { if (!expanded) return; activeIndex = i; try { path.style.opacity = '1'; } catch {} });
            path.addEventListener('mouseleave', () => { if (!expanded) return; activeIndex = -1; try { path.style.opacity = '0'; } catch {} });
            path.addEventListener('click', async () => {
              if (!expanded) return;
              const it = items[i];
              try { await window.compassAPI.pluginCall('screen.compass', 'performAction', [it]); } catch {}
              try { setExpanded(false); } catch {}
            });
            svg.appendChild(path);
          }
          sectors.appendChild(svg);
          try { sectors.style.pointerEvents = expanded ? 'auto' : 'none'; } catch {}
        }
        for (let i = 0; i < N; i++) {
          const it = items[i];
          const a = (Math.PI * 2) * ((i + 0.5) / Math.max(N, 1));
          const centerR = 25;
          const ro2 = Math.min(R + 14, Math.min(cx, cy) - 10);
          const ri2 = Math.max(centerR + 4, Math.round(R * 0.5));
          const RB = Math.round((ro2 + ri2) / 2);
          let x = Math.round(cx + RB * Math.cos(a));
          let y = Math.round(cy + RB * Math.sin(a));
          const div = document.createElement('div');
          div.className = 'item';
          div.style.position = 'absolute';
          const halfW = (theme === 'classic') ? 28 : 22;
          const halfH = 29;
          x = Math.max(halfW, Math.min(W - halfW, x));
          y = Math.max(halfH+1, Math.min(H - (halfH+1), y));
          div.style.left = (x - halfW) + 'px';
          div.style.top = (y - halfH) + 'px';
          div.title = it.label || '';
          const labelText = String(it.label || '').trim();
          if (theme === 'classic') { div.innerHTML = `<div class="dot"><i class="${it.icon || 'ri-circle-line'}"></i><div class="label">${labelText}</div></div>`; }
          else { div.innerHTML = `<i class="${it.icon || 'ri-circle-line'}"></i><div class="label">${labelText}</div>`; }
          const updateWedgesOpacity = () => {
            try {
              const wedges = sectors.querySelectorAll('.wedge');
              wedges.forEach((w)=>{ const idx = Number(w.dataset.index||-1); w.style.opacity = (expanded && idx===activeIndex) ? '1' : '0'; });
            } catch {}
          };
          div.addEventListener('mouseenter', () => { activeIndex = i; updateWedgesOpacity(); });
          div.addEventListener('mouseleave', () => { activeIndex = -1; updateWedgesOpacity(); });
          div.addEventListener('click', async () => {
            if (!expanded) return;
            try { await window.compassAPI.pluginCall('screen.compass', 'performAction', [it]); } catch {}
            try { setExpanded(false); } catch {}
          });
          ring.appendChild(div);
        }
      }

      function setExpanded(on) {
        expanded = !!on;
        const nodes = Array.from(ring.children);
        nodes.forEach(n => {
          if (expanded) { n.classList.remove('hidden'); }
          else { n.classList.add('hidden'); }
        });
      }

      center.addEventListener('click', () => { if (dragging || justDragged || toggleLock) return; toggleLock = true; setExpanded(!expanded); setTimeout(() => { toggleLock = false; }, 160); });

      let inactivityTimer = null;
      function resetInactivityTimer(){ try { if (inactivityTimer) clearTimeout(inactivityTimer); inactivityTimer = setTimeout(() => { if (expanded) setExpanded(false); }, 30000); } catch {} }

      let dragging = false; let startScreenX = 0; let startScreenY = 0; let lastScreenX = 0; let lastScreenY = 0; let lastClientX = 0; let lastClientY = 0; let startWinX = 0; let startWinY = 0; let moved = false; let justDragged = false; let rafScheduled = false; let nextX = 0; let nextY = 0; let downClientX = 0; let downClientY = 0; let boundsReady = false;
      function onPointerDown(e){
        dragging = true; moved = false; boundsReady = false; startScreenX = e.screenX; startScreenY = e.screenY; lastScreenX = startScreenX; lastScreenY = startScreenY; downClientX = e.clientX; downClientY = e.clientY; lastClientX = downClientX; lastClientY = downClientY;
        const inputType = String(e.pointerType||'').toLowerCase();
        try { e.preventDefault(); } catch {}
        try { center.setPointerCapture(e.pointerId); } catch {}
        window.compassAPI.getBounds().then((raw)=>{
          const b = (raw && raw.result) ? raw.result : raw;
          startWinX = (b && typeof b.x==='number')? b.x:0; startWinY = (b && typeof b.y==='number')? b.y:0; boundsReady = true;
          const offsetX = Math.max(0, (typeof e.screenX === 'number' ? e.screenX : 0) - startWinX);
          const offsetY = Math.max(0, (typeof e.screenY === 'number' ? e.screenY : 0) - startWinY);
          try { window.compassAPI.pluginCall('screen.compass','setDragging',[true, offsetX, offsetY, inputType]); } catch {}
        });
      }
      function onPointerMove(e){
        if (!dragging) return;
        try {
          const evs = (typeof e.getCoalescedEvents === 'function') ? e.getCoalescedEvents() : null;
          if (evs && evs.length) { const le = evs[evs.length-1]; lastClientX = le.clientX; lastClientY = le.clientY; lastScreenX = le.screenX; lastScreenY = le.screenY; }
          else { lastClientX = e.clientX; lastClientY = e.clientY; lastScreenX = e.screenX; lastScreenY = e.screenY; }
        } catch { lastClientX = e.clientX; lastClientY = e.clientY; lastScreenX = e.screenX; lastScreenY = e.screenY; }
        if (!boundsReady) { return; }
        const dx = lastClientX - downClientX, dy = lastClientY - downClientY;
        if (Math.abs(dx) > 2 || Math.abs(dy) > 2) moved = true;
        try { e.preventDefault(); } catch {}
        if (dragging && boundsReady && String(e.pointerType||'').toLowerCase()==='touch') {
          const dx = lastClientX - downClientX;
          const dy = lastClientY - downClientY;
          try { window.compassAPI.pluginCall('screen.compass','touchDragMove',[dx, dy]); } catch {}
        }
      }
      function onPointerUp(e){ try { center.releasePointerCapture(e.pointerId); } catch {} dragging=false; boundsReady=false; rafScheduled=false; if (moved) { justDragged = true; setTimeout(()=>{ justDragged=false; }, 200); } window.compassAPI.snap(); try { window.compassAPI.pluginCall('screen.compass','setDragging',[false]); } catch {} }
      function onPointerCancel(e){ try { center.releasePointerCapture(e.pointerId); } catch {} dragging=false; boundsReady=false; rafScheduled=false; moved=false; }
      center.addEventListener('pointerdown', onPointerDown);
      center.addEventListener('pointermove', onPointerMove);
      center.addEventListener('pointerup', onPointerUp);
      center.addEventListener('pointercancel', onPointerCancel);

      const iconEl = center.querySelector('i');
      function updateCenterIcon(){ try { iconEl.className = expanded ? 'ri-close-line' : centerIcon; iconEl.style.fontSize = Math.round(centerSize * 0.44) + 'px'; center.style.width = centerSize + 'px'; center.style.height = centerSize + 'px'; } catch {} }
      const __origSetExpanded = setExpanded;
      setExpanded = (on) => {
        if (window.__compassToggleTs && Date.now() - window.__compassToggleTs < 140) return; window.__compassToggleTs = Date.now();
        try { const w = on ? sizeExpanded : sizeCollapsed; window.compassAPI.pluginCall('screen.compass','setExpandedWindow',[!!on, w, w]); } catch {}
        let done = false;
        const run = () => { if (done) return; done = true; try { placeItems(); __origSetExpanded(on); updateCenterIcon(); if (expanded) resetInactivityTimer(); else { try { if (inactivityTimer) clearTimeout(inactivityTimer); } catch {} } } catch {} };
        const onResize = () => { try { window.removeEventListener('resize', onResize); } catch {} run(); };
        try { window.addEventListener('resize', onResize); } catch {}
        setTimeout(() => { if (!done) { try { window.removeEventListener('resize', onResize); } catch {} run(); } }, 140);
      };

      try { window.addEventListener('resize', () => { placeItems(); const nodes = Array.from(ring.children); nodes.forEach(n => { if (expanded) n.classList.remove('hidden'); else n.classList.add('hidden'); }); updateCenterIcon(); }); } catch {}
      (async function init(){ await ensureDefaults(); await loadItems(); placeItems(); setExpanded(false); })();

      // subscribe to updates from backend/settings
      try { window.compassAPI.subscribe('screen.compass'); } catch {}
      try {
        window.compassAPI.onEvent(async (name, payload) => {
          if (name !== 'screen.compass' || !payload) return;
          if (payload.type === 'buttons.update') {
            try {
              if (Array.isArray(payload.buttons)) { items = payload.buttons; }
              else { await loadItems(); }
              if (payload.theme) { theme = (payload.theme === 'sector') ? 'sector' : 'classic'; }
              if (payload.centerSize) {
                centerSize = Math.max(32, Math.min(160, Number(payload.centerSize) || centerSize));
                sizeCollapsed = Math.max(40, Math.min(240, centerSize + 10));
              } else if (payload.sizeCollapsed) {
                sizeCollapsed = Math.max(40, Math.min(240, Number(payload.sizeCollapsed) || sizeCollapsed));
                centerSize = Math.max(32, Math.min(160, sizeCollapsed - 10));
              }
              if (payload.sizeExpanded) sizeExpanded = Number(payload.sizeExpanded) || sizeExpanded;
              if (payload.centerIcon) centerIcon = String(payload.centerIcon) || centerIcon;
            } catch {}
            placeItems(); setExpanded(expanded);
          }
        });
      } catch {}
      // 点击空白区域收起（仅圆形背景以外的空白区域）
      const root = document.getElementById('root');
      root.addEventListener('click', (e) => { if (!expanded) return; if (e.target === root) setExpanded(false); });
      try {
        root.addEventListener('pointerdown', resetInactivityTimer);
        center.addEventListener('pointerdown', resetInactivityTimer);
        ring.addEventListener('pointerdown', resetInactivityTimer);
        document.getElementById('sectors').addEventListener('pointerdown', resetInactivityTimer);
      } catch {}
    </script>
  </body>
  </html>
